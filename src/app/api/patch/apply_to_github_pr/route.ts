export const dynamic = 'force-dynamic';

import { createClient } from '@supabase/supabase-js';
import { apiError, apiOk } from '@/lib/api/error';
import { gh } from '@/lib/github/client';
import { triggerWebhook } from '@/lib/webhooks/send';

function parseGitHubRepo(url: string) {
    const cleaned = url.replace('https://github.com/', '').replace(/^\/+/, '').replace(/\/+$/, '');
    const [owner, repo] = cleaned.split('/');
    return { owner, repo };
}

export async function POST(req: Request) {
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

    if (!supabaseUrl || !supabaseKey) {
        return apiError('Supabase configuration missing', 500);
    }

    const supabase = createClient(supabaseUrl, supabaseKey);

    try {
        const { patch_id, title, body: prBody } = await req.json();
        if (!patch_id) return apiError('patch_id is required', 400);

        // 1. Get patch from DB
        const { data: patch, error: patchErr } = await supabase
            .from('code_patches')
            .select('*, repositories(*)')
            .eq('id', patch_id)
            .single();

        if (patchErr || !patch) return apiError('Patch not found', 404);

        const repo = patch.repositories;
        const { owner, repo: repoName } = parseGitHubRepo(repo.repo_url);
        const branchName = `councilia/patch-${Math.random().toString(36).substring(7)}`;

        // 2. Create Branch
        const masterRef = await gh(`/repos/${owner}/${repoName}/git/ref/heads/master`);
        const sha = masterRef.object.sha;

        await gh(`/repos/${owner}/${repoName}/git/refs`, {
            method: 'POST',
            body: JSON.stringify({
                ref: `refs/heads/${branchName}`,
                sha
            })
        });

        // 3. Fetch current file content to get base SHA for commit
        const fileData = await gh(`/repos/${owner}/${repoName}/contents/${patch.file_path}`);

        // 4. Apply Patch (Simplificado para o MVP v2)
        const newContent = Buffer.from(Buffer.from(fileData.content, 'base64').toString('utf8') + `\n\n// CouncilIA: Applied Patch ${patch_id}`).toString('base64');

        await gh(`/repos/${owner}/${repoName}/contents/${patch.file_path}`, {
            method: 'PUT',
            body: JSON.stringify({
                message: `CouncilIA: ${title}`,
                content: newContent,
                sha: fileData.sha,
                branch: branchName
            })
        });

        // 5. Open PR
        const pr = await gh(`/repos/${owner}/${repoName}/pulls`, {
            method: 'POST',
            body: JSON.stringify({
                title: title || 'CouncilIA Contribution',
                body: prBody || 'This PR was automatically generated by CouncilIA based on code consensus.',
                head: branchName,
                base: 'master'
            })
        });

        // Update status
        await supabase.from('code_patches').update({
            status: 'applied'
        }).eq('id', patch_id);

        // Webhook
        await triggerWebhook({
            tenant_id: patch.tenant_id,
            event: 'patch.applied',
            payload: { patch_id: patch.id, pr_url: pr.html_url, branch: branchName }
        });

        return apiOk({ pr_url: pr.html_url, branch: branchName });

    } catch (error: any) {
        console.error('PR Error:', error);
        return apiError(error.message, 500);
    }
}
